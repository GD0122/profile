/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.16 Char1.glb 
*/

import React, { useEffect, useRef,MutableRefObject, useState } from 'react'
import { useGLTF, useAnimations, OrbitControls, PerspectiveCamera,} from '@react-three/drei'
import mod from './Hchars5.glb'
import useInput from '../hooks/useInputs'
import { useFrame, useThree } from '@react-three/fiber'
import * as THREE from 'three'
import { useBox, useCylinder, useSphere } from '@react-three/cannon'
import { Mesh } from 'three'
import { CuboidCollider, RigidBody } from '@react-three/rapier'
import { WireframeMaterial } from '@react-three/drei/materials/WireframeMaterial'
import { Vector3 } from 'three'


let walkDir = new THREE.Vector3()
let rotateAngle = new THREE.Vector3(0,1,0)
let rotateQuarternion = new THREE.Quaternion()
let cameraTarget = new THREE.Vector3()




const directionalOffset = ({moveForward,moveBackward,moveLeft,moveRight,})=>{
  let diroffset = 0;

  if(moveForward){
    if(moveLeft){
      diroffset= Math.PI/4
    }else if(moveRight){
      diroffset=-Math.PI/4
    }
  }else if(moveBackward){
    if(moveLeft){
      diroffset = Math.PI/4 + Math.PI /2
    }else if(moveRight){
      diroffset = -Math.PI/4 - Math.PI /2
    }else{
      diroffset = Math.PI
    }
  }else if(moveLeft){
    diroffset = Math.PI/2
  }else if(moveRight){
    diroffset = -Math.PI/2
  }

  return diroffset
}

export function Char1(props) {
  
  const {moveForward,moveBackward,moveLeft,moveRight,jump,shift} = useInput()
 
  const models = useGLTF(mod)
  const [speed,setSpeed] = useState(10)

  const {camera, scene} = useThree()
  const { actions } = useAnimations(models.animations, models.scene)
  const controlRef = useRef(null) // Correct usage of useRef
  const currAct = useRef("")

  const updateCamera = (moveX, moveZ) =>{
    camera.position.x += moveX
    camera.position.z += moveZ

    cameraTarget.x = refModel.current.position.x 
    cameraTarget.y = refModel.current.position.y + 2 
    cameraTarget.z = refModel.current.position.z

    if(controlRef.current) controlRef.current.target = cameraTarget


  
 
   
  
   
    
  }
 
  
  useEffect(()=>{
    // 
    let action = "";
    if(moveForward || moveBackward || moveLeft || moveRight){
      action="walking"
      if(shift){
        action='running'
      }
    }else if(jump){
      action="jump"
    }else{
      action = "idle"
    }
    if(currAct.current != action){
      const nextActToPlay = actions[action];
      const curr  = actions[currAct.current]
      curr?.fadeOut(0.2)
      nextActToPlay?.reset().fadeIn(0.2).play()
      currAct.current = action
    }
  },[moveForward,moveBackward,moveLeft,moveRight,jump,shift])


  useEffect(() => {
    actions['idle'].reset().fadeIn(0.2).play()
    camera.position.x += refModel.current.position.x
    camera.position.z += refModel.current.position.z
    camera.position.y += 2

    cameraTarget.x = refModel.current.position.x 
    cameraTarget.y = refModel.current.position.y + 2 
    cameraTarget.z = refModel.current.position.z

    if(controlRef.current) controlRef.current.target = cameraTarget
  
  }, []);

 const [refModel,modelApi] = useBox(()=>({
  type:'Dynamic',
  mass:10,
  fixedRotation:true,
  ...props,

  onCollide:(e)=>{
  
    if(e.contact.bi.name !== "plane"){
      wireframeMaterial.color.set('green')
    }
   
  
  
    
  },
  onCollideEnd:(e)=>{
   
      wireframeMaterial.color.set('white')
     
  }
  
 }),useRef())



const wireframeMaterial = new THREE.MeshBasicMaterial({
  color: 0xffffff, // warna kawat
  wireframe: true // mengaktifkan mode wireframe
});

// Buat box geometry
const boxGeometry = new THREE.BoxGeometry(1, 2, 1);

// Buat mesh dengan box geometry dan material wireframe
const boxMesh = new THREE.Mesh(boxGeometry, wireframeMaterial);
useEffect(() => {
  if (refModel.current) {
    refModel.current.add(boxMesh);
  }
}, [refModel]);
 
const velocity = useRef([-10,0,0])
useEffect(()=>{
    const unsubscribe = modelApi.velocity.subscribe((v) => (velocity.current = v))
    return unsubscribe
 
},[modelApi.velocity])
const JUMP = 10 
const SPEED = 10
useFrame((state,delta)=>{

 if(currAct.current =="running" || currAct.current == "walking"){
  let angleYCamDirection = Math.atan2(
    camera.position.x - refModel.current.position.x,
    camera.position.z - refModel.current.position.z
   )
   let newDirOffset = directionalOffset({
    moveForward,
    moveBackward,
    moveLeft,
    moveRight
   })
   rotateQuarternion.setFromAxisAngle(
    rotateAngle,
    angleYCamDirection + newDirOffset
   )
   models.scene.quaternion.rotateTowards(rotateQuarternion,0.2)
  
  
   
   camera.getWorldDirection(walkDir)
     walkDir.y = 0
     walkDir.normalize()
     walkDir.applyAxisAngle(rotateAngle,newDirOffset)
   const velo = currAct.current == "running"?3:2
   
   const moveX = walkDir.x * velo * speed
   const moveZ = walkDir.z * velo * speed
  
  
 
   modelApi.velocity.set(moveX,velocity.current[1],moveZ)
   refModel.current.getWorldPosition(refModel.current.position)


  //  updateCamera(moveX2,moveZ2)
  let cmX= walkDir.x * delta * (`${currAct.current==="running"?3:2}`-1)
  let cmZ= walkDir.z * delta * (`${currAct.current==="running"?3:2}`-1)
  updateCamera(cmX,cmZ)
 
  }
  // if(jump && Math.abs(velocity.current[1]) <= 0.0001){
  //   modelApi.velocity.set(velocity.current[0],5,velocity.current[2])
  //   setSpeed(3)
  //   setTimeout(() => {
  //     setSpeed(10);
  //   }, 2500)

  // }
  const previousCameraPosition = camera.position.clone();
  const raycaster = new THREE.Raycaster(camera.position, camera.getWorldDirection(new THREE.Vector3()));
  const walls = scene.getObjectByName('walls')
  if (walls) {
    const intersects = raycaster.intersectObjects(walls.children, true);
   
    // Cek apakah ada interseksi dengan dinding atau jaraknya kurang dari 2
    if (intersects.length > 0 && intersects[0].distance && intersects[0].distance.toFixed() <= 2) {
      // Kamera bertabrakan dengan dinding atau jaraknya kurang dari 2, kembalikan ke posisi sebelumnya
     
      camera.position.set(refModel.current.position.x +2,camera.position.y,refModel.current.position.x +2);
    } 
  }
  
})

const camPos = useRef<THREE.Camera>(null)
  return (
    <>
      
      <OrbitControls ref={controlRef}
       minDistance={3}
       maxDistance={5}
       maxPolarAngle={Math.PI/2}
    
      />
      {/* <PerspectiveCamera fov={75} /> */}
       <mesh ref={refModel} name='user' >
         <primitive  object={models.scene}  position={[0,-0.5,0]}/>
       </mesh>
      
    </>
    
  )
}

useGLTF.preload(mod)
